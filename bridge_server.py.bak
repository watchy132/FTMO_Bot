#!/usr/bin/env python3
# coding: utf-8

"""
Bridge HTTP très simple pour piloter les décisions.
Endpoints:
  GET  /health   -> état du bridge / MT5 (dummy si MT5 non dispo)
  POST /decide   -> renvoie des décisions JSON (debug/fallback immédiat)
Variables d'env (optionnelles):
  BRIDGE_HOST (def: 127.0.0.1)
  BRIDGE_PORT (def: 8765)
"""

from __future__ import annotations
import json, time, os
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any, Dict

HOST = os.getenv("BRIDGE_HOST", "127.0.0.1")
PORT = int(os.getenv("BRIDGE_PORT", "8765"))

def _json_bytes(obj: Dict[str, Any]) -> bytes:
    return json.dumps(obj, ensure_ascii=False).encode("utf-8")

def _health_payload() -> Dict[str, Any]:
    # Essaye d'importer MetaTrader5 uniquement pour indiquer l'état
    last_error = None
    try:
        import MetaTrader5  # noqa: F401
        mt5_ok = True
    except Exception as ex:  # MT5 pas dispo => ok False mais bridge OK
        mt5_ok = False
        last_error = f"import MetaTrader5 failed: {ex!s}"

    return {
        "ok": True,
        "meta": {
            "initialized": True,
            "connected": mt5_ok,
            "terminal": None,
            "version": None,
            "last_error": last_error,
            "time": int(time.time() * 1000),
        },
    }

def _skip_decision(symbol: str, reason: str) -> Dict[str, Any]:
    return {
        "action": "skip",
        "confidence": 65.0,
        "reason": reason,
        "symbol": symbol,
        "tf": "auto",
        "qty": None,
        "sl_pips": 0,
        "tp_pips": 0,
    }

def _forced_trade(symbol: str, side: str, lots: float | None) -> Dict[str, Any]:
    # side = "buy" / "sell"
    return {
        "action": side.lower(),
        "confidence": 91.0,
        "reason": "debug_force",
        "symbol": symbol,
        "tf": "auto",
        "qty": lots,
        "sl_pips": 0,
        "tp_pips": 0,
    }

class Handler(BaseHTTPRequestHandler):
    server_version = "BridgeServer/0"

    def _set_headers(self, status: int = 200) -> None:
        self.send_response(status)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.end_headers()

    # --- GET /health ---------------------------------------------------------
    def do_GET(self) -> None:  # noqa: N802
        if self.path.rstrip("/") == "/health":
            self._set_headers(200)
            self.wfile.write(_json_bytes(_health_payload()))
        else:
            self._set_headers(404)
            self.wfile.write(_json_bytes({"ok": False, "error": "not found"}))

    # --- POST /decide --------------------------------------------------------
    def do_POST(self) -> None:  # noqa: N802
        if self.path.rstrip("/") != "/decide":
            self._set_headers(404)
            self.wfile.write(_json_bytes({"ok": False, "error": "not found"}))
            return

        t0 = time.time()
        try:
            n = int(self.headers.get("Content-Length", "0"))
            raw = self.rfile.read(n) if n > 0 else b"{}"
            payload = json.loads(raw.decode("utf-8") or "{}")
        except Exception as ex:
            self._set_headers(400)
            self.wfile.write(_json_bytes({"ok": False, "error": f"bad json: {ex}"}))
            return

        symbols = payload.get("symbols") or ["EURUSD"]
        symbol = symbols[0] if isinstance(symbols, list) and symbols else "EURUSD"
        lots = payload.get("lots")
        debug_force = (payload.get("debug_force") or "").lower()
        probe = bool(payload.get("probe"))

        # Réponses immédiates :
        if debug_force in {"buy", "sell"}:
            decisions = [_forced_trade(symbol, debug_force, lots)]
            source = "debug"
        elif probe:
            decisions = [_skip_decision(symbol, "probe")]
            source = "probe"
        else:
            # Fallback neutre si pas de mode debug : on skip.
            decisions = [_skip_decision(symbol, "Insufficient signals for a clear trading decision.")]
            source = "fallback"

        resp = {
            "decisions": decisions,
            "meta": {
                "elapsed_ms": int((time.time() - t0) * 1000),
                "model": "local-bridge",
                "source": source,
            },
            "ok": True,
        }
        self._set_headers(200)
        self.wfile.write(_json_bytes(resp))

def main() -> None:
    httpd = HTTPServer((HOST, PORT), Handler)
    print(json.dumps({"status": "listening", "host": HOST, "port": PORT}))
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        httpd.server_close()

if __name__ == "__main__":
    main()
