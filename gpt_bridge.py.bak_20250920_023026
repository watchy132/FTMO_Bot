from __future__ import annotations
import os, time, json, re
from typing import Any, Dict, Optional, Tuple, List
import requests

# ===== Config =====
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL   = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
LLM_TIMEOUT_S  = float(os.getenv("LLM_TIMEOUT_S", "20"))

# ===== Utils =====
def _now_ms() -> int: return int(time.time()*1000)
def _ok(d: Dict[str, Any]) -> Dict[str, Any]:
    d.setdefault("ok", True); d.setdefault("ts", _now_ms()); return d

def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        try: return float(x.strip())
        except: return None
    return None

# ===== Normalisation =====
def normalize_setup(s: Dict[str, Any]) -> Tuple[Dict[str, Any], str]:
    if not isinstance(s, dict): return {}, "REJECT:not_dict"
    symbol = s.get("symbol") or s.get("ticker")
    direction = (s.get("direction") or s.get("side") or s.get("action") or "").upper()
    entry = _to_float(s.get("entry") or s.get("entry_price") or s.get("price"))
    sl    = _to_float(s.get("sl") or s.get("stop_loss") or s.get("stop") or s.get("sl_price"))
    tp    = _to_float(s.get("tp") or s.get("take_profit") or s.get("target") or s.get("tp_price"))

    if not symbol: return {}, "REJECT:missing_symbol"
    if direction not in ("BUY","SELL"): return {}, f"REJECT:bad_direction:{direction}"
    if entry is None or sl is None or tp is None: return {}, "REJECT:missing_prices"

    # cohérence simple
    if direction=="BUY" and not (sl < entry < tp): return {}, "REJECT:incoherent_buy"
    if direction=="SELL" and not (tp < entry < sl): return {}, "REJECT:incoherent_sell"

    # rrr
    rrr = None
    try:
        if direction=="BUY" and (entry-sl)>0: rrr = (tp-entry)/(entry-sl)
        if direction=="SELL" and (sl-entry)>0: rrr = (entry-tp)/(sl-entry)
    except ZeroDivisionError:
        rrr = None

    out = {
        "symbol": symbol,
        "direction": direction,
        "entry": float(entry),
        "sl": float(sl),
        "tp": float(tp),
        "rrr": rrr,
        "lots": _to_float(s.get("lots") or 0.01),
        "source": s.get("source","llm"),
    }
    return out, ""

# ===== LLM =====
_JSON_RE = re.compile(r"\{.*\}", re.S)

def _extract_json(txt: str) -> Optional[Dict[str, Any]]:
    m = _JSON_RE.search(txt or "")
    if not m: return None
    try: return json.loads(m.group(0))
    except Exception: return None

def _llm_decide(symbol: str) -> Tuple[Optional[Dict[str,Any]], str]:
    if not OPENAI_API_KEY: return None, "OPENAI_API_KEY missing"
    url = "https://api.openai.com/v1/chat/completions"
    org = os.getenv("OPENAI_ORG", "")
    proj = os.getenv("OPENAI_PROJECT", "")
    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type":"application/json"}
    if org:  headers["OpenAI-Organization"] = org
    if proj: headers["OpenAI-Project"] = proj
    sys_msg = (
        "Tu es un assistant de trading intraday. Réponds UNIQUEMENT en JSON, rien d'autre.\n"
        "Schéma exact: {\"symbol\":\"EURUSD\",\"direction\":\"BUY|SELL\",\"entry\":1.1000,\"sl\":1.0980,\"tp\":1.1040,\"reason\":\"texte court\"}\n"
        "Règles: pour BUY -> sl < entry < tp. Pour SELL -> tp < entry < sl. Valeurs plausibles pour EURUSD ~ 1.x."
    )
    user_msg = f"Décide sur {symbol} en M5 maintenant. Donne symbol, direction, entry, sl, tp, reason au format JSON strict."

    body = {
        "model": OPENAI_MODEL,
        "temperature": 0.2,
        "messages": [
            {"role":"system","content":sys_msg},
            {"role":"user","content":user_msg}
        ]
    }
    try:
        r = requests.post(url, headers=headers, json=body, timeout=LLM_TIMEOUT_S)
        r.raise_for_status()
        txt = r.json()["choices"][0]["message"]["content"]
        raw = _extract_json(txt) or {}
    except Exception as e:
        return None, f"llm_error:{e}"

    # compléter symbol si absent
    raw.setdefault("symbol", symbol)
    # uniformiser direction
    d = str(raw.get("direction") or raw.get("side") or raw.get("action") or "").upper()
    if d in ("LONG","ACHAT","BUY"): raw["direction"]="BUY"
    elif d in ("SHORT","VENTE","SELL"): raw["direction"]="SELL"
    # entry fallback
    if raw.get("entry") is None:
        p = _to_float(raw.get("price") or raw.get("entry_price"))
        if p is not None: raw["entry"]=p

    setup, err = normalize_setup(raw)
    if err: return None, f"normalize_error:{err}"
    setup["reason"] = str(raw.get("reason") or "llm")[:120]
    return setup, ""

# ===== Entrée principale =====
def decide(payload: Dict[str, Any], timeout: Optional[int]=None, **kwargs) -> Dict[str, Any]:
    # health
    if isinstance(payload, dict) and payload.get("probe") is True:
        return _ok({"decisions":[{"action":"ok","reason":"probe"}]})

    symbols = payload.get("symbols") or []
    symbol = symbols[0] if isinstance(symbols, list) and symbols else "EURUSD"

    # debug_force
    dbg = (payload.get("debug_force") or "").strip().lower() if isinstance(payload, dict) else ""
    if dbg in ("buy","sell"):
        mock = {"symbol": symbol, "direction": dbg.upper(), "entry":1.100, "sl":1.098 if dbg=="buy" else 1.102,
                "tp":1.104 if dbg=="buy" else 1.096, "source":"debug_force"}
        setup, err = normalize_setup(mock)
        if err: return _ok({"decisions": [], "status":"SKIP", "why": err})
        return _ok({"decisions":[{"action": dbg, "reason": f"debug_force {dbg}", "setups":[setup]}]})

    # LLM
    setup, err = _llm_decide(symbol)
    if err:
        return _ok({"decisions":[{"action":"skip","reason":err,"setups":[]} ]})
    return _ok({"decisions":[{"action": setup["direction"].lower(), "reason": setup.get("reason","llm"), "setups":[setup]}]})
