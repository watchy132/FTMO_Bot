from __future__ import annotations
import os, time, json, re
from typing import Any, Dict, Optional, Tuple, List
import requests

# ===== Config =====
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL   = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
LLM_TIMEOUT_S  = float(os.getenv("LLM_TIMEOUT_S", "20"))

# ===== Utils =====
def _now_ms() -> int: return int(time.time()*1000)
def _ok(d: Dict[str, Any]) -> Dict[str, Any]:
    d.setdefault("ok", True); d.setdefault("ts", _now_ms()); return d

def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        try: return float(x.strip())
        except: return None
    return None

# ===== Normalisation =====
def _extract_json(txt: str) -> Optional[Dict[str, Any]]:
    m = _JSON_RE.search(txt or "")
    if not m: return None
    try: return json.loads(m.group(0))
    except Exception: return None

def _llm_decide(symbol: str) -> Tuple[Optional[Dict[str,Any]], str]:
    if not OPENAI_API_KEY: return None, "OPENAI_API_KEY missing"
    url = "https://api.openai.com/v1/chat/completions"
    org = os.getenv("OPENAI_ORG", "")
    proj = os.getenv("OPENAI_PROJECT", "")
    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type":"application/json"}
    if org:  headers["OpenAI-Organization"] = org
    if proj: headers["OpenAI-Project"] = proj
    sys_msg = (
        "Tu es un assistant de trading intraday. Réponds UNIQUEMENT en JSON, rien d'autre.\n"
        "Schéma exact: {\"symbol\":\"EURUSD\",\"direction\":\"BUY|SELL\",\"entry\":1.1000,\"sl\":1.0980,\"tp\":1.1040,\"reason\":\"texte court\"}\n"
        "Règles: pour BUY -> sl < entry < tp. Pour SELL -> tp < entry < sl. Valeurs plausibles pour EURUSD ~ 1.x."
    )
    user_msg = f"Décide sur {symbol} en M5 maintenant. Donne symbol, direction, entry, sl, tp, reason au format JSON strict."

    body = {
        "model": OPENAI_MODEL,
        "temperature": 0.2,
        "messages": [
            {"role":"system","content":sys_msg},
            {"role":"user","content":user_msg}
        ]
    }
    try:
        r = requests.post(url, headers=headers, json=body, timeout=LLM_TIMEOUT_S)
        r.raise_for_status()
        txt = r.json()["choices"][0]["message"]["content"]
        raw = _extract_json(txt) or {}
    except Exception as e:
        return None, f"llm_error:{e}"

    # compléter symbol si absent
    raw.setdefault("symbol", symbol)
    # uniformiser direction
    d = str(raw.get("direction") or raw.get("side") or raw.get("action") or "").upper()
    if d in ("LONG","ACHAT","BUY"): raw["direction"]="BUY"
    elif d in ("SHORT","VENTE","SELL"): raw["direction"]="SELL"
    # entry fallback
    if raw.get("entry") is None:
        p = _to_float(raw.get("price") or raw.get("entry_price"))
        if p is not None: raw["entry"]=p

    setup, err = normalize_setup(raw)
    if err: return None, f"normalize_error:{err}"
    setup["reason"] = str(raw.get("reason") or "llm")[:120]
    return setup, ""

# ===== Entrée principale =====
def decide(payload: Dict[str, Any], timeout: Optional[int]=None, **kwargs) -> Dict[str, Any]:
    # health
    if isinstance(payload, dict) and payload.get("probe") is True:
        return _ok({"decisions":[{"action":"ok","reason":"probe"}]})

    symbols = payload.get("symbols") or []
    symbol = symbols[0] if isinstance(symbols, list) and symbols else "EURUSD"

    # debug_force
    dbg = (payload.get("debug_force") or "").strip().lower() if isinstance(payload, dict) else ""
    if dbg in ("buy","sell"):
        mock = {"symbol": symbol, "direction": dbg.upper(), "entry":1.100, "sl":1.098 if dbg=="buy" else 1.102,
                "tp":1.104 if dbg=="buy" else 1.096, "source":"debug_force"}
        setup, err = normalize_setup(mock)
        if err: return _ok({"decisions": [], "status":"SKIP", "why": err})
        return _ok({"decisions":[{"action": dbg, "reason": f"debug_force {dbg}", "setups":[setup]}]})

    # LLM
    setup, err = _llm_decide(symbol)
    if err:
        return _ok({"decisions":[{"action":"skip","reason":err,"setups":[]} ]})
    return _ok({"decisions":[{"action": setup["direction"].lower(), "reason": setup.get("reason","llm"), "setups":[setup]}]})

# --- Normalisation robuste des setups ---

from typing import Any, Dict, List, Tuple, Union

def _to_float(x):
    if x is None:
        return None
    if isinstance(x, (int, float)):
        return float(x)
    if isinstance(x, str):
        try:
            return float(x.strip())
        except Exception:
            return None
    return None

_DIR_ALIASES = {
    "buy": "BUY", "long": "BUY", "bull": "BUY", "up": "BUY",
    "sell": "SELL", "short": "SELL", "bear": "SELL", "down": "SELL",
}

def _norm_direction(x: Any) -> Union[str, None]:
    if not x:
        return None
    s = str(x).strip().lower()
    return _DIR_ALIASES.get(s) or (s.upper() if s in ("BUY", "SELL") else None)

def _norm_symbol(x: Any) -> Union[str, None]:
    if not x:
        return None
    s = str(x).strip().upper().replace(" ", "")
    return s if len(s) >= 3 else None

def _compute_tp(entry: float, sl: float, direction: str, rrr: float) -> float:
    if direction == "BUY":
        return entry + rrr * abs(entry - sl)
    else:
        return entry - rrr * abs(entry - sl)

def _valid_side(entry: float, sl: float, tp: float, direction: str) -> bool:
    if direction == "BUY":
        return sl < entry < tp
    else:
        return tp < entry < sl

def _calc_rrr(entry: float, sl: float, tp: float) -> float:
    den = abs(entry - sl)
    num = abs(tp - entry)
    return num / den if den > 0 else 0.0

def normalize_setup(s: Dict[str, Any]) -> Tuple[Dict[str, Any], str]:
    if not isinstance(s, dict):
        return {}, "REJECT: not a dict"

    symbol = _norm_symbol(s.get("symbol") or s.get("ticker") or s.get("pair"))
    direction = _norm_direction(s.get("direction") or s.get("side"))
    entry = _to_float(s.get("entry") or s.get("price") or s.get("entry_price"))
    sl = _to_float(s.get("sl") or s.get("stop_loss") or s.get("stop"))
    tp = _to_float(s.get("tp") or s.get("take_profit") or s.get("target"))
    rrr = _to_float(s.get("rrr") or s.get("rr") or s.get("risk_reward") or s.get("reward_risk"))
    lots = _to_float(s.get("lots") or s.get("size") or s.get("quantity"))
    source = s.get("source")

    if not symbol:
        return {}, "REJECT: missing symbol"
    if direction not in ("BUY", "SELL"):
        return {}, "REJECT: missing/invalid direction"
    if entry is None or entry <= 0:
        return {}, "REJECT: missing/invalid entry"
    if sl is None or sl <= 0:
        return {}, "REJECT: missing/invalid sl"

    if (tp is None or tp <= 0) and (rrr is not None and rrr > 0):
        tp = _compute_tp(entry, sl, direction, rrr)

    if (rrr is None or rrr <= 0) and (tp is not None and tp > 0):
        rrr = _calc_rrr(entry, sl, tp)

    if tp is not None and not _valid_side(entry, sl, tp, direction):
        if _valid_side(entry, tp, sl, direction):
            sl, tp = tp, sl
        elif rrr is not None and rrr > 0:
            tp = _compute_tp(entry, sl, direction, rrr)

    if tp is None or tp <= 0:
        return {}, "REJECT: missing/invalid tp"
    if not _valid_side(entry, sl, tp, direction):
        return {}, f"REJECT: inconsistent levels for {direction} (sl/entry/tp)"

    rrr = _calc_rrr(entry, sl, tp)
    if rrr <= 0:
        return {}, "REJECT: non-positive RRR"
    if rrr > 10:
        return {}, "REJECT: RRR > 10 looks invalid"

    out = {
        "symbol": symbol,
        "direction": direction,
        "entry": float(entry),
        "sl": float(sl),
        "tp": float(tp),
        "rrr": float(rrr),
    }
    if lots and lots > 0:
        out["lots"] = float(lots)
    if source:
        out["source"] = str(source)

    return out, "OK"

def normalize_setups(setups: Union[List[Any], Dict[str, Any], None]) -> Tuple[List[Dict[str, Any]], List[str]]:
    valids = []
    reasons = []

    if setups is None:
        return [], ["REJECT: setups is None"]

    if isinstance(setups, dict):
        norm, why = normalize_setup(setups)
        if norm:
            valids.append(norm)
        reasons.append(why)
        return valids, reasons

    if isinstance(setups, list):
        for i, s in enumerate(setups):
            norm, why = normalize_setup(s)
            if norm:
                valids.append(norm)
            reasons.append(f"{i}: {why}")
        return valids, reasons

    return [], ["REJECT: setups not list/dict"]
