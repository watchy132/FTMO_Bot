from __future__ import annotations
# __JSON_RE_BUILTINS__
try:
    __bi._JSON_RE
except Exception:
    import re as __rb
    __bi._JSON_RE = __rb.compile(r"(\{[\s\S]*\}|\[[\s\S]*\])", __rb.S)
import os, time, json, re
from typing import Any, Dict, Optional, Tuple, List
import requests

# ===== Config =====
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL   = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
LLM_TIMEOUT_S  = float(os.getenv("LLM_TIMEOUT_S", "20"))

# ===== Utils =====
def _now_ms() -> int: return int(time.time()*1000)
def _ok(d: Dict[str, Any]) -> Dict[str, Any]:
    d.setdefault("ok", True); d.setdefault("ts", _now_ms()); return d

def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        try: return float(x.strip())
        except: return None
    return None

# ===== Normalisation =====
def _extract_json(txt: str) -> Optional[Dict[str, Any]]:
    m = _JSON_RE.search(txt or "")
    if not m: return None
    try: return json.loads(m.group(0))
    except Exception: return None

def _llm_decide(symbol: str) -> Tuple[Optional[Dict[str,Any]], str]:
    if not OPENAI_API_KEY: return None, "OPENAI_API_KEY missing"
    url = "https://api.openai.com/v1/chat/completions"
    org = os.getenv("OPENAI_ORG", "")
    proj = os.getenv("OPENAI_PROJECT", "")
    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type":"application/json"}
    if org:  headers["OpenAI-Organization"] = org
    if proj: headers["OpenAI-Project"] = proj
    sys_msg = (
        "Tu es un assistant de trading intraday. Réponds UNIQUEMENT en JSON, rien d'autre.\n"
        "Schéma exact: {\"symbol\":\"EURUSD\",\"direction\":\"BUY|SELL\",\"entry\":1.1000,\"sl\":1.0980,\"tp\":1.1040,\"reason\":\"texte court\"}\n"
        "Règles: pour BUY -> sl < entry < tp. Pour SELL -> tp < entry < sl. Valeurs plausibles pour EURUSD ~ 1.x."
    )
    user_msg = f"Décide sur {symbol} en M5 maintenant. Donne symbol, direction, entry, sl, tp, reason au format JSON strict."

    body = {
        "model": OPENAI_MODEL,
        "temperature": 0.2,
        "messages": [
            {"role":"system","content":sys_msg},
            {"role":"user","content":user_msg}
        ]
    }
    try:
        r = requests.post(url, headers=headers, json=body, timeout=LLM_TIMEOUT_S)
        r.raise_for_status()
        txt = r.json()["choices"][0]["message"]["content"]
        raw = _extract_json(txt) or {}
    except Exception as e:
        return None, f"llm_error:{e}"

    # compléter symbol si absent
    raw.setdefault("symbol", symbol)
    # uniformiser direction
    d = str(raw.get("direction") or raw.get("side") or raw.get("action") or "").upper()
    if d in ("LONG","ACHAT","BUY"): raw["direction"]="BUY"
    elif d in ("SHORT","VENTE","SELL"): raw["direction"]="SELL"
    # entry fallback
    if raw.get("entry") is None:
        p = _to_float(raw.get("price") or raw.get("entry_price"))
        if p is not None: raw["entry"]=p

    setup, err = normalize_setup(raw)
    if err: return None, f"normalize_error:{err}"
    setup["reason"] = str(raw.get("reason") or "llm")[:120]
    return setup, ""

# ===== Entrée principale =====
def decide(payload: Dict[str, Any], timeout: Optional[int]=None, **kwargs) -> Dict[str, Any]:
    # health
    if isinstance(payload, dict) and payload.get("probe") is True:
        return _ok({"decisions":[{"action":"ok","reason":"probe"}]})

    symbols = payload.get("symbols") or []
    symbol = symbols[0] if isinstance(symbols, list) and symbols else "EURUSD"

    # debug_force
    dbg = (payload.get("debug_force") or "").strip().lower() if isinstance(payload, dict) else ""
    if dbg in ("buy","sell"):
        mock = {"symbol": symbol, "direction": dbg.upper(), "entry":1.100, "sl":1.098 if dbg=="buy" else 1.102,
                "tp":1.104 if dbg=="buy" else 1.096, "source":"debug_force"}
        setup, err = normalize_setup(mock)
        if err: return _ok({"decisions": [], "status":"SKIP", "why": err})
        return _ok({"decisions":[{"action": dbg, "reason": f"debug_force {dbg}", "setups":[setup]}]})

    # LLM
    setup, err = _llm_decide(symbol)
    if err:
        return _ok({"decisions":[{"action":"skip","reason":err,"setups":[]} ]})
    return _ok({"decisions":[{"action": setup["direction"].lower(), "reason": setup.get("reason","llm"), "setups":[setup]}]})

# --- Normalisation robuste des setups ---

from typing import Any, Dict, List, Tuple, Union

def _to_float(x):
    if x is None:
        return None
    if isinstance(x, (int, float)):
        return float(x)
    if isinstance(x, str):
        try:
            return float(x.strip())
        except Exception:
            return None
    return None

_DIR_ALIASES = {
    "buy": "BUY", "long": "BUY", "bull": "BUY", "up": "BUY",
    "sell": "SELL", "short": "SELL", "bear": "SELL", "down": "SELL",
}

def _norm_direction(x: Any) -> Union[str, None]:
    if not x:
        return None
    s = str(x).strip().lower()
    return _DIR_ALIASES.get(s) or (s.upper() if s in ("BUY", "SELL") else None)

def _norm_symbol(x: Any) -> Union[str, None]:
    if not x:
        return None
    s = str(x).strip().upper().replace(" ", "")
    return s if len(s) >= 3 else None

def _compute_tp(entry: float, sl: float, direction: str, rrr: float) -> float:
    if direction == "BUY":
        return entry + rrr * abs(entry - sl)
    else:
        return entry - rrr * abs(entry - sl)

def _valid_side(entry: float, sl: float, tp: float, direction: str) -> bool:
    if direction == "BUY":
        return sl < entry < tp
    else:
        return tp < entry < sl

def _calc_rrr(entry: float, sl: float, tp: float) -> float:
    den = abs(entry - sl)
    num = abs(tp - entry)
    return num / den if den > 0 else 0.0

# disabled legacy normalize_setup
def normalize_setup_disabled(*a, **k):
    return ({}, "REJECT: disabled") if "normalize_setup"=="normalize_setup" else ([], ["REJECT: disabled"])
# disabled legacy normalize_setups
def normalize_setups_disabled(*a, **k):
    return ({}, "REJECT: disabled") if "normalize_setups"=="normalize_setup" else ([], ["REJECT: disabled"])
def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        try: return float(x.strip())
        except: return None
    return None

def _norm_direction(x: Any) -> Union[str,None]:
    if not x: return None
    s=str(x).strip().lower()
    return _DIR_ALIASES.get(s) or (s.upper() if s in ("buy","sell","BUY","SELL") else None)

def _norm_symbol(x: Any) -> Union[str,None]:
    if not x: return None
    s=str(x).strip().upper().replace(" ","")
    return s if len(s)>=3 else None

def _compute_tp(entry: float, sl: float, direction: str, rrr: float) -> float:
    return entry + rrr*abs(entry-sl) if direction=="BUY" else entry - rrr*abs(entry-sl)

def _valid_side(entry: float, sl: float, tp: float, direction: str) -> bool:
    return (sl < entry < tp) if direction=="BUY" else (tp < entry < sl)

def _calc_rrr(entry: float, sl: float, tp: float) -> float:
    den=abs(entry-sl); num=abs(tp-entry)
    return num/den if den>0 else 0.0

# ---- JSON helpers ----
_JSON_BLOCK_RE = re.compile(r"```(?:json)?\s*([\s\S]*?)\s*```", re.I)

def extract_json_v2(text):
    if not isinstance(text,str): return None
    m=_JSON_BLOCK_RE.search(text)
    cand=m.group(1).strip() if m else text.strip()
    try: return json.loads(cand)
    except Exception: pass
    # tentative simple: chercher premier { ou [
    i=min([j for j in (cand.find("{"),cand.find("[")) if j!=-1], default=-1)
    if i>=0:
        sub=cand[i:]
        for k in range(len(sub),1,-1):
            try: return json.loads(sub[:k])
            except Exception: pass
    return None

# ---- Freeform "PLACE BUY ..." ----
_FREEFORM_DIR_SYM_RE = re.compile(r'(?i)\b(?:PLACE\s+)?(BUY|SELL)\s+([A-Z0-9._/]{3,20})')
def _grab_num(label, text):
    m=re.search(r'(?i)\b'+re.escape(label)+r'\s*[:=]\s*([-+]?\d+(?:\.\d+)?)', text)
    return float(m.group(1)) if m else None

def _parse_freeform_setups(text):
    if not isinstance(text,str) or len(text)<8: return []
    m=_FREEFORM_DIR_SYM_RE.search(text)
    if not m: return []
    direction, symbol = m.group(1).upper(), m.group(2).upper().replace(" ","")
    entry = _grab_num("entry",text) or _grab_num("price",text)
    sl    = _grab_num("sl",text) or _grab_num("stop",text) or _grab_num("stop_loss",text)
    tp    = _grab_num("tp",text) or _grab_num("take_profit",text) or _grab_num("target",text)
    rrr   = _grab_num("rrr",text) or _grab_num("rr",text) or _grab_num("reward_risk",text)
    lots  = _grab_num("lots",text) or _grab_num("size",text) or _grab_num("quantity",text)

    out={"symbol":symbol,"direction":direction,"source":"freeform"}
    if entry is not None: out["entry"]=entry
    if sl    is not None: out["sl"]=sl
    if tp    is not None: out["tp"]=tp
    if rrr   is not None: out["rrr"]=rrr
    if lots  is not None: out["lots"]=lots
    return [out]

# ---- Normalisation v2 ----
def normalize_setup_v2(s: Dict[str,Any]) -> Tuple[Dict[str,Any], str]:
    if not isinstance(s,dict): return {}, "REJECT: not a dict"

    symbol = _norm_symbol(s.get("symbol") or s.get("ticker") or s.get("pair") or s.get("instrument") or s.get("asset"))
    direction = _norm_direction(s.get("direction") or s.get("side") or s.get("dir"))
    entry = _to_float(s.get("entry") or s.get("price") or s.get("entry_price") or s.get("open") or s.get("entryPrice"))
    sl = _to_float(s.get("sl") or s.get("stop_loss") or s.get("stop") or s.get("stoploss") or s.get("stopPrice"))
    tp = _to_float(s.get("tp") or s.get("take_profit") or s.get("target") or s.get("takeprofit") or s.get("targetPrice"))
    rrr = _to_float(s.get("rrr") or s.get("rr") or s.get("risk_reward") or s.get("reward_risk"))
    lots = _to_float(s.get("lots") or s.get("size") or s.get("quantity"))
    source = s.get("source")

    if not symbol: return {}, "REJECT: missing symbol"
    if direction not in ("BUY","SELL"): return {}, "REJECT: missing/invalid direction"
    if entry is None or entry<=0: return {}, "REJECT: missing/invalid entry"
    if sl is None or sl<=0: return {}, "REJECT: missing/invalid sl"

    if (tp is None or tp<=0) and (rrr is not None and rrr>0):
        tp=_compute_tp(entry,sl,direction,rrr)
    if (rrr is None or rrr<=0) and (tp is not None and tp>0):
        rrr=_calc_rrr(entry,sl,tp)

    if tp is not None and not _valid_side(entry,sl,tp,direction):
        if _valid_side(entry,tp,sl,direction): sl,tp = tp,sl
        elif rrr is not None and rrr>0: tp=_compute_tp(entry,sl,direction,rrr)

    if tp is None or tp<=0: return {}, "REJECT: missing/invalid tp"
    if not _valid_side(entry,sl,tp,direction): return {}, f"REJECT: inconsistent levels for {direction}"

    rrr=_calc_rrr(entry,sl,tp)
    if rrr<=0: return {}, "REJECT: non-positive RRR"
    if rrr>10: return {}, "REJECT: RRR > 10 looks invalid"

    out={"symbol":symbol,"direction":direction,"entry":float(entry),"sl":float(sl),"tp":float(tp),"rrr":float(rrr)}
    if lots and lots>0: out["lots"]=float(lots)
    if source: out["source"]=str(source)
    return out,"OK"

def normalize_setups_v2(setups):
    """
    Accepte list/dict, wrappers {"setups":[...]},{"candidates":[...]},{"decision":{"setups":[...]}}
    ou str (JSON ou texte libre "PLACE BUY ...").
    """
    valids,reasons=[],[]

    if isinstance(setups,str):
        obj=extract_json_v2(setups)
        if obj is not None:
            setups=obj
        else:
            ff=_parse_freeform_setups(setups)
            if ff: setups=ff

    if setups is None:
        return [], ["REJECT: setups is None"]

    if isinstance(setups,dict):
        for k in ("setups","candidates"):
            if isinstance(setups.get(k),list):
                setups=setups[k]; break
        if isinstance(setups,dict) and isinstance(setups.get("decision",{}).get("setups"),list):
            setups=setups["decision"]["setups"]

    if isinstance(setups,list):
        for i,item in enumerate(setups):
            norm,why=normalize_setup_v2(item if isinstance(item,dict) else {"symbol":None})
            if norm: valids.append(norm)
            reasons.append(f"{i}: {why}")
        return valids,reasons

    if isinstance(setups,dict):
        norm,why=normalize_setup_v2(setups)
        if norm: valids.append(norm)
        reasons.append(why)
        return valids,reasons

    return [], ["REJECT: setups not list/dict"]

# expose v2
normalize_setup = normalize_setup_v2
normalize_setups = normalize_setups_v2
# === END normalization_v2 ===
# === BEGIN normalization_v2 ===
from typing import Any, Dict, List, Tuple, Union
import json, re, builtins as __bi, os

_DIR_ALIASES = {"buy":"BUY","long":"BUY","bull":"BUY","up":"BUY",
                "sell":"SELL","short":"SELL","bear":"SELL","down":"SELL"}

def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        try: return float(x.strip())
        except: return None
    return None

def _norm_direction(x: Any) -> Union[str,None]:
    if not x: return None
    s=str(x).strip().lower()
    return _DIR_ALIASES.get(s) or (s.upper() if s in ("buy","sell","BUY","SELL") else None)

def _norm_symbol(x: Any) -> Union[str,None]:
    if not x: return None
    s=str(x).strip().upper().replace(" ","")
    return s if len(s)>=3 else None

def _compute_tp(entry: float, sl: float, direction: str, rrr: float) -> float:
    return entry + rrr*abs(entry-sl) if direction=="BUY" else entry - rrr*abs(entry-sl)

def _valid_side(entry: float, sl: float, tp: float, direction: str) -> bool:
    return (sl < entry < tp) if direction=="BUY" else (tp < entry < sl)

def _calc_rrr(entry: float, sl: float, tp: float) -> float:
    den=abs(entry-sl); num=abs(tp-entry)
    return num/den if den>0 else 0.0

_JSON_BLOCK_RE = re.compile(r"```(?:json)?\s*([\s\S]*?)\s*```", re.I)
def extract_json_v2(text):
    if not isinstance(text,str): return None
    m=_JSON_BLOCK_RE.search(text)
    cand=m.group(1).strip() if m else text.strip()
    try: return json.loads(cand)
    except Exception: return None

_FREEFORM_DIR_SYM_RE = re.compile(r'(?i)\b(?:PLACE\s+)?(BUY|SELL)\s+([A-Z0-9._/]{3,20})')
def _grab_num(label, text):
    import re as _re
    m=_re.search(r'(?i)\b'+_re.escape(label)+r'\s*[:=]\s*([-+]?\d+(?:\.\d+)?)', text)
    return float(m.group(1)) if m else None

def _parse_freeform_setups(text):
    if not isinstance(text,str) or len(text)<8: return []
    m=_FREEFORM_DIR_SYM_RE.search(text)
    if not m: return []
    direction, symbol = m.group(1).upper(), m.group(2).upper().replace(" ","")
    entry = _grab_num("entry",text) or _grab_num("price",text)
    sl    = _grab_num("sl",text) or _grab_num("stop",text) or _grab_num("stop_loss",text)
    tp    = _grab_num("tp",text) or _grab_num("take_profit",text) or _grab_num("target",text)
    rrr   = _grab_num("rrr",text) or _grab_num("rr",text) or _grab_num("reward_risk",text)
    lots  = _grab_num("lots",text) or _grab_num("size",text) or _grab_num("quantity",text)
    out={"symbol":symbol,"direction":direction,"source":"freeform"}
    if entry is not None: out["entry"]=entry
    if sl    is not None: out["sl"]=sl
    if tp    is not None: out["tp"]=tp
    if rrr   is not None: out["rrr"]=rrr
    if lots  is not None: out["lots"]=lots
    return [out]

def normalize_setup_v2(s: Dict[str,Any]) -> Tuple[Dict[str,Any], str]:
    if not isinstance(s,dict): return {}, "REJECT: not a dict"
    symbol = _norm_symbol(s.get("symbol") or s.get("ticker") or s.get("pair") or s.get("instrument") or s.get("asset"))
    direction = _norm_direction(s.get("direction") or s.get("side") or s.get("dir"))
    entry = _to_float(s.get("entry") or s.get("price") or s.get("entry_price") or s.get("open") or s.get("entryPrice"))
    sl = _to_float(s.get("sl") or s.get("stop_loss") or s.get("stop") or s.get("stoploss") or s.get("stopPrice"))
    tp = _to_float(s.get("tp") or s.get("take_profit") or s.get("target") or s.get("takeprofit") or s.get("targetPrice"))
    rrr = _to_float(s.get("rrr") or s.get("rr") or s.get("risk_reward") or s.get("reward_risk"))
    lots = _to_float(s.get("lots") or s.get("size") or s.get("quantity"))
    source = s.get("source")
    if not symbol: return {}, "REJECT: missing symbol"
    if direction not in ("BUY","SELL"): return {}, "REJECT: missing/invalid direction"
    if entry is None or entry<=0: return {}, "REJECT: missing/invalid entry"
    if sl is None or sl<=0: return {}, "REJECT: missing/invalid sl"
    if (tp is None or tp<=0) and (rrr is not None and rrr>0): tp=_compute_tp(entry,sl,direction,rrr)
    if (rrr is None or rrr<=0) and (tp is not None and tp>0): rrr=_calc_rrr(entry,sl,tp)
    if tp is not None and not _valid_side(entry,sl,tp,direction):
        if _valid_side(entry,tp,sl,direction): sl,tp = tp,sl
        elif rrr is not None and rrr>0: tp=_compute_tp(entry,sl,direction,rrr)
    if tp is None or tp<=0: return {}, "REJECT: missing/invalid tp"
    if not _valid_side(entry,sl,tp,direction): return {}, f"REJECT: inconsistent levels for {direction}"
    rrr=_calc_rrr(entry,sl,tp)
    if rrr<=0: return {}, "REJECT: non-positive RRR"
    if rrr>10: return {}, "REJECT: RRR > 10 looks invalid"
    out={"symbol":symbol,"direction":direction,"entry":float(entry),"sl":float(sl),"tp":float(tp),"rrr":float(rrr)}
    if lots and lots>0: out["lots"]=float(lots)
    if source: out["source"]=str(source)
    return out,"OK"

def normalize_setups_v2(setups):
    valids,reasons=[],[]
    if isinstance(setups,str):
        obj=extract_json_v2(setups)
        if obj is not None: setups=obj
        else:
            ff=_parse_freeform_setups(setups)
            if ff: setups=ff
    if setups is None: return [], ["REJECT: setups is None"]
    if isinstance(setups,dict):
        for k in ("setups","candidates"):
            if isinstance(setups.get(k),list): setups=setups[k]; break
        if isinstance(setups,dict) and isinstance(setups.get("decision",{}).get("setups"),list):
            setups=setups["decision"]["setups"]
    if isinstance(setups,list):
        for i,item in enumerate(setups):
            norm,why=normalize_setup_v2(item if isinstance(item,dict) else {"symbol":None})
            if norm: valids.append(norm)
            reasons.append(f"{i}: {why}")
        return valids,reasons
    if isinstance(setups,dict):
        norm,why=normalize_setup_v2(setups)
        if norm: valids.append(norm)
        reasons.append(why)
        return valids,reasons
    return [], ["REJECT: setups not list/dict"]

normalize_setup = normalize_setup_v2
normalize_setups = normalize_setups_v2
# === END normalization_v2 ===

# LOAD_ENV_FALLBACK
if not os.getenv('OPENAI_API_KEY'):
    try:
        with open('.env','r',encoding='utf-8') as f:
            for line in f:
                if line.startswith('OPENAI_API_KEY='):
                    os.environ['OPENAI_API_KEY']=line.strip().split('=',1)[1]
                    break
    except Exception:
        pass


# === normalization_v2.1 (tolerant floats, symbols, entry inference) ===
def _to_float(x):
    if x is None: return None
    if isinstance(x,(int,float)): return float(x)
    if isinstance(x,str):
        raw=x
        s=x.strip().replace('\u00a0','').replace(' ','').replace("'",'')
        s=s.replace(',', '.')
        try: return float(s)
        except Exception:
            import re as _re
            m=_re.search(r'[-+]?\d+(?:[.,]\d+)?', raw)
            if m: return float(m.group(0).replace(',', '.'))
            return None
    return None

def _norm_symbol(x):
    if not x: return None
    import re as _re
    s=str(x).upper()
    s=_re.sub(r'[^A-Z0-9]', '', s)  # EUR/USD -> EURUSD
    return s if len(s)>=3 else None

def normalize_setup_v2(s: Dict[str,Any]) -> Tuple[Dict[str,Any], str]:
    if not isinstance(s,dict): return {}, "REJECT: not a dict"
    symbol = _norm_symbol(s.get("symbol") or s.get("ticker") or s.get("pair") or s.get("instrument") or s.get("asset"))
    direction = _norm_direction(s.get("direction") or s.get("side") or s.get("dir"))
    entry = _to_float(s.get("entry") or s.get("price") or s.get("entry_price") or s.get("open") or s.get("entryPrice"))
    sl = _to_float(s.get("sl") or s.get("stop_loss") or s.get("stop") or s.get("stoploss") or s.get("stopPrice"))
    tp = _to_float(s.get("tp") or s.get("take_profit") or s.get("target") or s.get("takeprofit") or s.get("targetPrice"))
    rrr = _to_float(s.get("rrr") or s.get("rr") or s.get("risk_reward") or s.get("reward_risk"))
    lots = _to_float(s.get("lots") or s.get("size") or s.get("quantity"))
    source = s.get("source")

    if not symbol: return {}, "REJECT: missing symbol"
    if direction not in ("BUY","SELL"): return {}, "REJECT: missing/invalid direction"

    # entry inference if only sl/tp given
    if entry is None and (sl and tp and sl>0 and tp>0):
        if direction=="BUY" and sl<tp: entry=(sl+tp)/2.0
        if direction=="SELL" and tp<sl: entry=(sl+tp)/2.0

    if entry is None or entry<=0: return {}, "REJECT: missing/invalid entry"
    if sl is None or sl<=0: return {}, "REJECT: missing/invalid sl"

    if (tp is None or tp<=0) and (rrr and rrr>0): tp=_compute_tp(entry,sl,direction,rrr)
    if (rrr is None or rrr<=0) and (tp and tp>0): rrr=_calc_rrr(entry,sl,tp)

    if tp is not None and not _valid_side(entry,sl,tp,direction):
        if _valid_side(entry,tp,sl,direction): sl,tp = tp,sl
        elif rrr and rrr>0: tp=_compute_tp(entry,sl,direction,rrr)

    if tp is None or tp<=0: return {}, "REJECT: missing/invalid tp"
    if not _valid_side(entry,sl,tp,direction): return {}, f"REJECT: inconsistent levels for {direction}"

    rrr=_calc_rrr(entry,sl,tp)
    if rrr<=0: return {}, "REJECT: non-positive RRR"
    if rrr>10: return {}, "REJECT: RRR > 10 looks invalid"

    out={"symbol":symbol,"direction":direction,"entry":float(entry),"sl":float(sl),"tp":float(tp),"rrr":float(rrr)}
    if lots and lots>0: out["lots"]=float(lots)
    if source: out["source"]=str(source)
    return out,"OK"

normalize_setup = normalize_setup_v2


def _unwrap_llm_response(obj):
    try:
        if isinstance(obj, dict) and obj.get('choices'):
            ch=obj['choices'][0]
            return (ch.get('message') or {}).get('content') or ch.get('text')
    except Exception:
        return None
    return None



def normalize_setups_v3(setups):
    import os, time
    # log entrée
    try:
        fn=os.path.join(os.getcwd(),'norm_in_%d.txt'%int(time.time()*1000))
        with open(fn,'w',encoding='utf-8') as f: f.write(repr(setups))
    except Exception: pass

    # 1) str -> JSON ou freeform
    if isinstance(setups, str):
        obj = (_json_try_block(setups) if "_json_try_block" in globals() else _json_try_local(setups))
        setups = obj if obj is not None else (_parse_freeform_setups(setups) or setups)

    # 2) OpenAI formats (content | tool_calls | function_call)
    if isinstance(setups, dict):
        ext = _extract_from_openai(setups)
        if isinstance(ext, str):
            obj = (_json_try_block(ext) if "_json_try_block" in globals() else _json_try_local(ext))
            setups = obj if obj is not None else (_parse_freeform_setups(ext) or setups)
        elif isinstance(ext, (dict, list)):
            setups = ext

    # 3) unwrap ordre-like
    if isinstance(setups, dict):
        uw = _order_like_to_setup(setups)
        if uw: setups = uw

    # 4) collections usuelles
    if isinstance(setups, dict):
        for k in ('setups','candidates'):
            if isinstance(setups.get(k), list):
                setups = setups[k]; break
        if isinstance(setups, dict) and isinstance(setups.get('decision',{}).get('setups'), list):
            setups = setups['decision']['setups']

    return normalize_setups_v2(setups)

normalize_setups = normalize_setups_v3




_DEBUG_WRAP=False
try:
    if not _DEBUG_WRAP:
        _orig_normalize_setups = normalize_setups
        def normalize_setups(x):
            import os, time
            try:
                os.makedirs('/tmp/ftmo_bot', exist_ok=True)
                fn='/tmp/ftmo_bot/norm_in_%d.txt' % int(time.time()*1000)
                with open(fn,'w',encoding='utf-8') as f: f.write(repr(x))
            except Exception:
                pass
            return _orig_normalize_setups(x)
        _DEBUG_WRAP=True
except Exception:
    pass

_ORDER_TYPE_ALIASES = {
    "buy_limit":"BUY","buy_stop":"BUY","sell_limit":"SELL","sell_stop":"SELL",
    "market_buy":"BUY","market_sell":"SELL"
}

def _unwrap_order_like(d):
    # d peut être {"action":"PLACE","side":"BUY","symbol":"EURUSD",...}
    # ou {"order":{...}} ou {"type":"BUY_LIMIT", ...}
    if not isinstance(d, dict): return None
    cand = d.get('order') if isinstance(d.get('order'), dict) else d
    side = cand.get('side') or cand.get('direction') or cand.get('type')
    sym  = cand.get('symbol') or cand.get('ticker') or cand.get('pair')
    if side or sym or any(k in cand for k in ('sl','tp','stop','take_profit','entry','price','target')):
        out = dict(cand)
        if side and isinstance(side,str):
            out['direction'] = side
        return out
    return None

# ##__JSON_FALLBACK__
try:
    _JSON_RE
except NameError:
    import re as __r
    _JSON_RE = __r.compile(r"(\{[\s\S]*\}|\[[\s\S]*\])", __r.S)

def _extract_from_openai(obj):
    if not isinstance(obj, dict): return None
    # root-level content
    if isinstance(obj.get('content'), str): return obj['content']
    # choices -> message.content / text
    chs = obj.get('choices') or []
    if chs:
        ch = chs[0] or {}
        msg = ch.get('message') or {}
        # tool_calls(function.arguments)
        tcs = msg.get('tool_calls') or []
        for t in tcs:
            func = (t or {}).get('function', {})
            args = func.get('arguments')
            if isinstance(args, str):
                v = (_json_try_block(args) if "_json_try_block" in globals() else _json_try_local(args))
                if v is not None: return v
        # function_call.arguments (legacy)
        fcall = msg.get('function_call') or ch.get('function_call') or {}
        args = fcall.get('arguments')
        if isinstance(args, str):
            v = (_json_try_block(args) if "_json_try_block" in globals() else _json_try_local(args))
            if v is not None: return v
        # plain content/text
        content = msg.get('content') or ch.get('text')
        if isinstance(content, str): return content
    return None

def _order_like_to_setup(d):
    if not isinstance(d, dict): return None
    cand = d.get('order') if isinstance(d.get('order'), dict) else d
    side = cand.get('side') or cand.get('direction') or cand.get('type')
    sym  = cand.get('symbol') or cand.get('ticker') or cand.get('pair')
    if side or sym or any(k in cand for k in ('entry','price','sl','stop','tp','take_profit','target')):
        out=dict(cand)
        if side and isinstance(side,str): out['direction']=side
        return out
    return None

def _json_try_local(text):
    import re as _re, json as _json
    if not isinstance(text,str): return None
    t=text.strip()
    t=_re.sub(r'^```(?:json)?\s*','',t, flags=_re.I)
    t=_re.sub(r'\s*```$','',t)
    try: return _json.loads(t)
    except Exception: pass
    m=_re.search(r'(\{[\s\S]*\}|\[[\s\S]*\])', t)
    if m:
        try: return _json.loads(m.group(1))
        except Exception: pass
    return None
