from rm_policy import validate_setup, lot_size, rr_effectif
from __future__ import annotations
import math
from dataclasses import dataclass

@dataclass
class SymbolSpec:
    tick_size: float
    tick_value: float   # $ par tick pour 1.0 lot
    lot_step: float
    min_lot: float
    max_lot: float
    digits: int

DEFAULT_SPECS = {
    "EURUSD":      SymbolSpec(0.0001, 10.0, 0.01, 0.01, 100.0, 5),
    "XAUUSD":      SymbolSpec(0.01,   10.0, 0.01, 0.01, 100.0, 2),
    "US30.cash":   SymbolSpec(1.0,     1.0, 0.1,  0.1,  100.0, 0),
    "NAS100.cash": SymbolSpec(0.1,     1.0, 0.1,  0.1,  100.0, 1),
    "BTCUSD":      SymbolSpec(0.01,    1.0, 0.01, 0.01, 100.0, 2),
}

FTMO_LIMITS = {
    "MAX_DD_DAY":   0.05,
    "SOFT_STOP_DAY":0.042,
    "MAX_DD_TOTAL": 0.095,
    "MIN_RRR":      2.0,
}

def round_step(value: float, step: float) -> float:
    return math.floor(value/step + 1e-9) * step

def sl_distance_pips(entry: float, sl: float, tick_size: float) -> float:
    return abs(entry - sl) / tick_size

def lot_for_risk(
    balance: float,
    risk_pct: float,
    sl_pips: float,
    *,
    tick_value: float,
    tick_size: float,
    lot_step: float,
    min_lot: float,
    max_lot: float,
    spread_pips: float = 0.0,
    commission_per_lot: float = 0.0,
    slippage_pips: float = 0.0,
) -> float:
    if sl_pips <= 0:
        return 0.0
    risk_amount = balance * risk_pct
    cost_per_pip_per_lot = tick_value / tick_size
    effective_sl = sl_pips + spread_pips + slippage_pips
    if effective_sl <= 0:
        return 0.0
    lot = risk_amount / (effective_sl * cost_per_pip_per_lot)
    if commission_per_lot > 0:
        lot = max(0.0, (risk_amount - commission_per_lot) / (effective_sl * cost_per_pip_per_lot))
    lot = max(min_lot, min(max_lot, round_step(lot, lot_step)))
    return lot

def dd_guard(today_dd_pct: float, total_dd_pct: float) -> tuple[bool, str]:
    if today_dd_pct >= FTMO_LIMITS["MAX_DD_DAY"]:
        return False, "HARD_STOP_DAY_5pct"
    if today_dd_pct >= FTMO_LIMITS["SOFT_STOP_DAY"]:
        return False, "SOFT_STOP_DAY_4.2pct"
    if total_dd_pct >= FTMO_LIMITS["MAX_DD_TOTAL"]:
        return False, "HARD_STOP_TOTAL_9.5pct"
    return True, "OK"

def enforce_rrr(rrr: float, min_rrr: float = FTMO_LIMITS["MIN_RRR"]) -> bool:
    try:
        return float(rrr) >= float(min_rrr)
    except Exception:
        return False

if __name__ == "__main__":
    spec = DEFAULT_SPECS["EURUSD"]
    bal = 200_000
    risk = 0.005
    sl_pips = 20
    lot = lot_for_risk(
        balance=bal, risk_pct=risk, sl_pips=sl_pips,
        tick_value=spec.tick_value, tick_size=spec.tick_size,
        lot_step=spec.lot_step, min_lot=spec.min_lot, max_lot=spec.max_lot,
        spread_pips=1.0, commission_per_lot=6.0, slippage_pips=0.5,
    )
    print({"lot": lot})
