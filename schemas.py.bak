from __future__ import annotations
import json
from typing import List, Optional

# Pydantic v1/v2 compatible import lÃ©ger
try:
    from pydantic import BaseModel, Field, ValidationError
except Exception:  # fallback minimal si pydantic indisponible
    BaseModel = object
    Field = lambda default=None, **_: default
    class ValidationError(Exception):
        ...

# --- ENUMS -----------------------------------------------------

class Direction(str):
    BUY = "BUY"
    SELL = "SELL"

class Action(str):
    SKIP = "SKIP"
    PENDING = "PENDING"
    PLACE = "PLACE"

# --- MODELS ----------------------------------------------------

class Setup(BaseModel):  # type: ignore[misc]
    symbol: str = Field(...)
    timeframe: str = Field(..., description="ex: M5, M15, H1")
    direction: str = Field(..., description="BUY ou SELL")
    entry: float = Field(...)
    sl: float = Field(...)
    tp: float = Field(...)
    rrr: float = Field(..., description=">= 2.0")
    confidence: float = Field(..., description="0..1")
    rationale: str = Field(...)
    flags: List[str] = Field(default_factory=list)

class RiskBlock(BaseModel):  # type: ignore[misc]
    risk_pct: float = Field(..., description="ex: 0.0025 = 0.25%")

class Decision(BaseModel):  # type: ignore[misc]
    action: str = Field(..., description="PLACE / SKIP / PENDING")
    expires_at: Optional[str] = Field(None, description="UTC datetime ISO")
    setup: Optional[Setup] = None
    risk: Optional[RiskBlock] = None
    reason: Optional[str] = None

# --- UTILS -----------------------------------------------------

def parse_decision(js: str) -> Decision:
    """
    Parse la sortie JSON de GPT et renvoie un objet Decision.
    Si le JSON est invalide, renvoie une Decision(action=SKIP).
    """
    try:
        data = json.loads(js)
        return Decision(**data)
    except (json.JSONDecodeError, ValidationError, TypeError, KeyError) as e:
        return Decision(action=Action.SKIP, reason=f"Invalid JSON: {e}")
